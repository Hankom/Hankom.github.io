---
layout: post
title: 분할 정복 알고리즘
---


# 분할 정복 알고리즘

**분할 정복(Divide-and-Conquer)** 알고리즘이란 주어진 문제의 입력을 분할하여 문제를 해결(정복)하는 방식의 알고리즘이다.
분할된 입력에 대하여 동일한 알고리즘을 적용하여 해를 계산하며, 이들의 해를 취합하여 원래 문제의 해를 얻는다. 여기서 분할된 입력에 대한 문제를 **부분문제(subproblem)** 라고 하고, 부분문제의 해를 부분해라고 한다. 부분문제는 더 이상 분할할 수 없을 때까지 계속 분할한다.


> **분할 정복 알고리즘의 분류:** 분할 정복 알고리즘은 분할되는 부분문제의 수와 부분문제의 크기에 따라서 다음과 같이 분류할 수 있다.

- 문제가 a개로 분할되고, 부분문제의 크기가 1/b로 감소하는 알고리즘
- - a=b=2인 경우, 합병 정렬, 최근접 점의 쌍 찾기(3.4절), 공제선 문제
- - a=3, b=2인 경우, 큰 정수의 곱셈
- - a=4, b=2인 경우, 큰 정수의 곱셈
- - a=7, b=2인 경우, 스트라센(Strassen)의 행렬 곱셈 알고리즘
- 문제가 2개로 분할되나, 그중에 1개의 부분문제는 고려할 필요 없으며, 부분문제의 크기가 1/2로 감소하는 알고리즘:이진탐색(1.2절)
- 문제가 2개로 분할되나, 그중에 1개의 부분문제는 고려할 필요 없으며, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘: 선택 문제 알고리즘
- 부분문제의 크기가 1, 2개씩 감소하는 알고리즘: 삽입 정렬, 피보나치 수의 계산

## 합병 정렬(Merge Sort)

![1](https://raw.githubusercontent.com/Hankom/Hankom.github.io/main/assets/img/mergesort.png)

합병 정렬(Merge Sort)은 입력이 2개의 부분문제로 분할되고, 부분문제의 크기가 1/2로 감소하는 분할 정복 알고리즘이다.
즉, n개의 숫자들을 n/2개씩 2개의 부분문제로 분할하고, 각각의 부분문제를 순환적으로 합병 정렬한 후, 2개의 정렬된 부분을 합병하여 정렬(정복)한다. 즉, 합병 과정이 (문제를) 정복하는 것이다.

>MergeSort(A,p,q)\
입력:A[p]~A[q]\
출력:정렬된 A[p]~A[q]\
1 if (p < q) {\
2 ...  k=[(p+q)/2]\
3 ...  MergeSort(A,p,k)\
4 ...  MergeSort(A,k+1,q)\
5 ...  A[p] ~ A[k]와 A[k+1] ~ A[q]\
}


- Line 1에서는 정렬할 부분의 원소의 수가 2개 이상일 때에만 다음 단계가 수행되도록 한다. 만일 p=q(즉, 원소의 수가 1)이면, 그 자체로 정렬된 것이므로 Line 2~5가 수행되지 않은 채 이전 호출했던 곳으로 리턴한다.
- Line 2에서는 정렬할 부분의 원소들을 1/2로 나누기 위해, k = [(p+q)/2]를 계산한다. 단, 원소의 수가 홀수인 경우, k는 소수점 이하를 버린 정수이다.
- Line 3~4에서는 MergeSort(A,p,k)와 MergeSort(A,k+1,q)를 순환 호출하여 각각 정렬한다.
- Line 5에서는 Line 3~4 에서 각각 정렬된 부분을 합병한다. 합병 과정의 마지막에는 임시 배열에 있는 합병된 원소들을 배열 A로 복사한다. 즉, 임시 배열 B[p]~B[q]를 A[p]~A[q]로 복사한다.

## 퀵 정렬(Quick Sort)

퀵 정렬(Quick Sort)은 분할 정복 알고리즘으로 분류되나, 사실 알고리즘이 수행되는 과정을 살펴보면 정복 후 분할하는 알고리즘이다. 퀵 정렬 알고리즘은 문제를 2개의 부분문제로 분할하는데, 각 부분문제의 크기가 일정하지 않은 형태의 분할 정복 알고리즘이다.

![2](https://raw.githubusercontent.com/Hankom/Hankom.github.io/main/assets/img/quicksort.gif)

퀵 정렬의 아이디어는 피봇(pivot)이라 일컫는 배열의 원소(숫자)를 기준으로 피봇보다 작은 숫자들은 왼편으로, 피봇보다 큰 숫자들은 오른편에 위치하도록 분할하고, 피봇을 그 사이에 놓는 것이다. 퀵 정렬은 분할된 부분문제들에 대하여서도 위와 동일한 과정을 순환적으로 수행하여 정렬한다.

>QuickSort(A,left,right)\
입력:배열 A[left]~A[right]\
출력:정렬된 배열 A[left]~A[right]\
1 if (left < right) {\
2 ...  피봇을 A[left]~A[right] 중에서 선택하고, 피봇을 A[left]와 .자리를 바꾼 후, 피봇과 배열의 각 원소를 비교하여 피봇보다 작은 숫자들을 A[left]~A[p-1]로 옮기고, 피봇보다 큰 숫자들을 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다.\
3 ...  QuickSort(A,left,p-1)\
4 ...  MergeSort(A,p+1 right)\
}

- Line 1에서는 배열 A의 가장 왼쪽 원소의 인덱스(left)가 가장 오른쪽 원소의 인덱스(right)보다 작으면, Line 2~4에서 정렬을 수행한다. 만일 그렇지 않으면 left = right이므로, 더 이상 분할할 수 없는 크기, 즉 1개의 원소를 정렬하는 경우이다. 그러나 1개의 원소는 그 자체가 이미 정렬된 것이므로, Line 2~4의 정렬 과정을 수행할 필요 없이 그대로 호출을 마친다.
- Line 2에서는 A[left]~A[right]에서 피봇을 선택하고, 배열 A[left+1]~A[right]의 원소들을 피봇과 각각 비교하여, 피봇보다 작은 그룹인 A[left]~A[p-1]과 피봇보다 큰 그룹인 A[p+1]~A[right]로 분할하고 피봇을 A[p]에 위치시킨다. 즉, p는 피봇이 위치하게 되는 배열 A의 인덱스이다.
- Line 3에서는 피봇보다 작은 그룹인 A[left]~A[p-1]을 순환적으로 호출한다.
- Line 4에서는 피봇보다 큰 숫자들을 A[p+1]~A[right]를 순환적으로 호출한다.
